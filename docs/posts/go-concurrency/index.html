<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go Concurrency | Research Team</title><meta name=keywords content="go,operating system"><meta name=description content="Table of content General
Goroutine
Wait group
Channel
Worker pool
Rate limit
References
General  If there&rsquo;s one thing most people know about Go, is that it is designed for concurrency (1).
&ndash; Andrew Gerrand &ndash;
 Concurrency and parallelism  Concurrency is dealing with multiple things at once, parallelism is doing multiple things at once.
 Concurrency is not parallelism, although it enables parallelism.
If you have only one processor, your program can still be concurrent but it cannot be parallel."><meta name=author content="Pham Minh Toan, Huynh Hong An, Pham Quoc Dat"><link rel=canonical href=https://sdt-research-team.github.io/posts/go-concurrency/><meta name=google-site-verification content="XYZabc"><link href=https://sdt-research-team.github.io/assets/css/stylesheet.min.d1bc2b736056bd5698d770eeedc08a73bce9e6cebb30810f6f1b2c2048e46ab8.css integrity="sha256-0bwrc2BWvVaY13Du7cCKc7zp5s67MIEPbxssIEjkarg=" rel="preload stylesheet" as=style><link rel=icon href=https://sdt-research-team.github.io/%3Cpath%20/%20external%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://sdt-research-team.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sdt-research-team.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://sdt-research-team.github.io/apple-touch-icon.png><link rel=mask-icon href=https://sdt-research-team.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.1"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-123-45','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Go Concurrency"><meta property="og:description" content="Table of content General
Goroutine
Wait group
Channel
Worker pool
Rate limit
References
General  If there&rsquo;s one thing most people know about Go, is that it is designed for concurrency (1).
&ndash; Andrew Gerrand &ndash;
 Concurrency and parallelism  Concurrency is dealing with multiple things at once, parallelism is doing multiple things at once.
 Concurrency is not parallelism, although it enables parallelism.
If you have only one processor, your program can still be concurrent but it cannot be parallel."><meta property="og:type" content="article"><meta property="og:url" content="https://sdt-research-team.github.io/posts/go-concurrency/"><meta property="og:image" content="https://sdt-research-team.github.io/60"><meta property="article:published_time" content="2021-01-14T09:57:01+07:00"><meta property="article:modified_time" content="2021-01-14T09:57:01+07:00"><meta property="og:site_name" content="Research Team"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sdt-research-team.github.io/60"><meta name=twitter:title content="Go Concurrency"><meta name=twitter:description content="Table of content General
Goroutine
Wait group
Channel
Worker pool
Rate limit
References
General  If there&rsquo;s one thing most people know about Go, is that it is designed for concurrency (1).
&ndash; Andrew Gerrand &ndash;
 Concurrency and parallelism  Concurrency is dealing with multiple things at once, parallelism is doing multiple things at once.
 Concurrency is not parallelism, although it enables parallelism.
If you have only one processor, your program can still be concurrent but it cannot be parallel."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go Concurrency","name":"Go Concurrency","description":"Table of content General\nGoroutine\nWait group\nChannel\nWorker pool\nRate limit\nReferences\nGeneral  If there\u0026amp;rsquo;s one thing most people know about Go, is that it is designed for …","keywords":["go","operating system"],"articleBody":"Table of content General\nGoroutine\nWait group\nChannel\nWorker pool\nRate limit\nReferences\nGeneral  If there’s one thing most people know about Go, is that it is designed for concurrency (1).\n– Andrew Gerrand –\n Concurrency and parallelism  Concurrency is dealing with multiple things at once, parallelism is doing multiple things at once.\n Concurrency is not parallelism, although it enables parallelism.\nIf you have only one processor, your program can still be concurrent but it cannot be parallel. On the other hand, a well-written concurrent program might run efficiently in parallel on a multiprocessor\nSource: https://medium.com/rungo/achieving-concurrency-in-go-3f84cbf870ca\nProcess and thread A process is created by the operating system for the application. The job of the process is to act like a container for all the resources the application uses and maintains as it runs. These resources include things like a memory address space, handles to files, devices and threads.\nA thread is a path of execution that is scheduled by the operating system to execute the code we write. The process starts with 1 thread, the main thread, and when that thread terminates the process terminates. This is because the main thread is the origin for the application. The main thread can then in turn launch more threads and those threads can launch even more threads.\nConcurrent program in Golang Today, modern systems are fast because they are using multiple cores. It is useful since we can split up bit process into smaller threads.\nHowever, many basic tutorial only allow you to use one processor core because using multiple cores requires real threads. And it is totally hard because each thread will finish at a different time, and usually out of order. In reality, some tasks may require you to combine the result of each thread, and be impacted by the order in which you combine the results.\nInstead of real threads, Go supports goroutines, which are lightweight threads. Go can handle goroutines by using tools from the language’s stdlib itself. Moreover, Go can provide the right number of real threads to handle goroutines you spawn.\nAt any point in time, one thread will be executing one goroutine and if that goroutine is blocked, then it will be swapped out for another goroutine that will execute on that thread. It looks like thread scheduling but handled by Go runtime and this is much faster.\nA go routine is initally created with 2kb of stack size. Each function in go already has a check if more stack is needed or not and the stack can be copied to another region in memory with twice the original size. This makes goroutine very light on resources.\n   Key GoRoutine Thread     Managed By Goroutine methods are managed by golang runtime. Thread are managed by operating systems.   Hardware dependency Goroutine are independent to hardware. Thread are dependent on hardware.   Communication Medium Goroutines uses channels as communication medium. Thread have no easy communication medium.   Latency Goroutines can commuicate with other routines with low latency. Thread as have no communication medium, communicate with other thread with high latency.   ID Goroutine does not have any thread local storage and no unique id. Thread have thread local storage and have unique id.   Scheduling Goroutines are co-operatively scheduled. Threads are preemptively scheduled.   Startup Goroutines have faster startup time. Threads have slower startup time.   Stack Goroutines have growable segmented stacks. Threads do not have growable segmented stacks.    Imagine, you have a web server, this server is handling 1000 requests per second. If an OS thread consume 1MB stack size per thread, that means it takes 1GB of RAM for that traffic.\nIn case of goroutines, since stack size can grow dynamically, you can spawn 1000 goroutines without problems. As a goroutine starts with 8KB, most of them generally do not grow bigger than that\nGoroutine The number of CPUs available simultaneously to executing goroutines is controlled by the GOMAXPROCS shell environment variable, whose default value is the number of CPU cores available (2)\nBasic syntax Goroutine in a loop\nfunc main() { for i := 0; i 10; i++ { go println(i) } //Wait for all goroutine done before main terminated \ttime.Sleep(1 * time.Second) } Output\n1 9 2 3 4 5 6 8 0 7 Goroutine under the hood   When initialize a goroutine, it uses stacks. It provides a few KBs of stack RAM, which is almost always enough. This amount of RAM is based on strategy of Golang, for example (3):\n Go 1.2: goroutine stack has been increased from 4Kb to 8Kb. Go 1.4: goroutine stack has decreased from 8Kb to 2Kb.    When goroutine size overflow the init size. Runtime Golang has some methods for stack management:\n Segmented stacks  Example, we have stack S1 is currently init by a goroutine G1. If the stack S1 is almost full, a call will force a new stack chunk to be allocated.\n Problem: This approach can become hell if the stack is almost full in a loop, it will create multiple useless segments.   Stack copying  Example, we have stack S1 is currently init by a goroutine G1. If the stack S1 is almost full, it will allocate another stack S2 and copy all S1 data to S2 (S1 will be cleaning up later by garbage collector)\n      Why goroutines instead of threads? Wait group Basic syntax func worker(id int, wg *sync.WaitGroup) { defer wg.Done() //Decrease counter by one  fmt.Printf(\"Worker %d starting\\n\", id) time.Sleep(time.Second) fmt.Printf(\"Worker %d done\\n\", id) } func main() { var wg sync.WaitGroup for i := 1; i  5; i++ { wg.Add(1) //Increase counter by one  go worker(i, \u0026wg) } wg.Wait() //Wait for counter until zero } WaitGroup and concurrency WaitGroup is independent with concurrency programing. Because you can use it without any goroutines. Example:\nfunc waitGroupWithoutGoroutine() { var wg = sync.WaitGroup{} wg.Add(5) for i := 1; i  5; i++ { fmt.Println(\"Doing task #\", i) wg.Done() } wg.Wait() } But WaitGroup is developed for concurrency. The type WaitGroup is in package sync which is provides basic synchronization primitives (thread or process synchronization frameworks).\nWaitGroup specifications:  Should not be copied. When passing a wait group variable to a goroutine function, it should be passed by pointer reference. Use stack pointer to store counter value.  Channel Worker pool Rate Limit References (1) https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes\n(2) https://golang.org/doc/faq#number_cpus\n(3) https://medium.com/a-journey-with-go/go-how-does-the-goroutine-stack-size-evolve-447fc02085e5\n","wordCount":"1044","inLanguage":"en","datePublished":"2021-01-14T09:57:01+07:00","dateModified":"2021-01-14T09:57:01+07:00","author":{"@type":"Person","name":"Pham Minh Toan, Huynh Hong An, Pham Quoc Dat"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sdt-research-team.github.io/posts/go-concurrency/"},"publisher":{"@type":"Organization","name":"Research Team","logo":{"@type":"ImageObject","url":"https://sdt-research-team.github.io/%3Cpath%20/%20external%20url%3E"}}}</script></head><body><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://sdt-research-team.github.io accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://sdt-research-team.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://sdt-research-team.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Go Concurrency</h1><div class=post-meta>January 14, 2021&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Pham Minh Toan, Huynh Hong An, Pham Quoc Dat</div></header><div class=post-content><h3 id=table-of-content>Table of content<a hidden class=anchor aria-hidden=true href=#table-of-content>#</a></h3><p><a href=#general>General</a><br><a href=#goroutine>Goroutine</a><br><a href=#wait-group>Wait group</a><br><a href=#channel>Channel</a><br><a href=#worker-pool>Worker pool</a><br><a href=#rate-limit>Rate limit</a><br><a href=#references>References</a></p><h3 id=general>General<a hidden class=anchor aria-hidden=true href=#general>#</a></h3><blockquote><p>If there&rsquo;s one thing most people know about Go, is that it is designed for concurrency <a href=#1>(1)</a>.<br>&ndash; Andrew Gerrand &ndash;</p></blockquote><h4 id=concurrency-and-parallelism>Concurrency and parallelism<a hidden class=anchor aria-hidden=true href=#concurrency-and-parallelism>#</a></h4><blockquote><p><strong>Concurrency</strong> is dealing with multiple things at once, <strong>parallelism</strong> is doing multiple things at once.</p></blockquote><p>Concurrency is not parallelism, although it enables parallelism.</p><p>If you have only one processor, your program can still be concurrent but it cannot be parallel. On the other hand, a well-written concurrent program might run efficiently in parallel on a multiprocessor</p><p><img src=../../static/images/0_X0pg_FAWAv93kpii.jpg alt=0_X0pg_FAWAv93kpii></p><p><img src=../../static/images/0_8NBpRcm6HQ4tfxgs.jpg alt=0_8NBpRcm6HQ4tfxgs></p><p><img src=https://s3-ap-southeast-1.amazonaws.com/dwarvesf-outline/uploads/7ae21154-1975-4f97-a6ec-a937c42cab44/9f016ca4-46ab-46fc-a9bb-65dc7eb50798/preview-full-image.png alt="After understanding the way to compare concurrency with parallelism, we can research about Goroutines/channel and other well.">
<em>Source: <a href=https://medium.com/rungo/achieving-concurrency-in-go-3f84cbf870ca>https://medium.com/rungo/achieving-concurrency-in-go-3f84cbf870ca</a></em></p><h4 id=process-and-thread>Process and thread<a hidden class=anchor aria-hidden=true href=#process-and-thread>#</a></h4><p>A process is created by the operating system for the application. The job of the process is to act like a container for all the resources the application uses and maintains as it runs. These resources include things like a memory address space, handles to files, devices and threads.</p><p>A thread is a path of execution that is scheduled by the operating system to execute the code we write. The process starts with 1 thread, the main thread, and when that thread terminates the process terminates. This is because the main thread is the origin for the application. The main thread can then in turn launch more threads and those threads can launch even more threads.</p><p><img src="https://codejournal.io/images/node-internals-post/threads.png?fbclid=IwAR3JRC_5XssHdKwhc6MXScEQ8vGxa1UGtIlHH3ycCB5Rw8mMwBFw1S6u1c4" alt="process and thread"></p><h4 id=concurrent-program-in-golang>Concurrent program in Golang<a hidden class=anchor aria-hidden=true href=#concurrent-program-in-golang>#</a></h4><p>Today, modern systems are fast because they are using multiple cores. It is useful since we can split up bit process into smaller threads.</p><p>However, many basic tutorial only allow you to use one processor core because using multiple cores requires real threads. And it is totally hard because each thread will finish at a different time, and usually out of order. In reality, some tasks may require you to combine the result of each thread, and be impacted by the order in which you combine the results.</p><p>Instead of real threads, Go supports goroutines, which are lightweight threads. Go can handle goroutines by using tools from the language&rsquo;s stdlib itself. Moreover, Go can provide the right number of real threads to handle goroutines you spawn.</p><p>At any point in time, one thread will be executing one goroutine and if that goroutine is blocked, then it will be swapped out for another goroutine that will execute on that thread. It looks like <strong>thread scheduling</strong> but handled by <strong>Go runtime</strong> and this is much faster.</p><p>A go routine is initally created with 2kb of stack size. Each function in go already has a check if more stack is needed or not and the stack can be copied to another region in memory with twice the original size. This makes goroutine very light on resources.</p><table><thead><tr><th>Key</th><th>GoRoutine</th><th>Thread</th></tr></thead><tbody><tr><td>Managed By</td><td>Goroutine methods are managed by golang runtime.</td><td>Thread are managed by operating systems.</td></tr><tr><td>Hardware dependency</td><td>Goroutine are independent to hardware.</td><td>Thread are dependent on hardware.</td></tr><tr><td>Communication Medium</td><td>Goroutines uses channels as communication medium.</td><td>Thread have no easy communication medium.</td></tr><tr><td>Latency</td><td>Goroutines can commuicate with other routines with low latency.</td><td>Thread as have no communication medium, communicate with other thread with high latency.</td></tr><tr><td>ID</td><td>Goroutine does not have any thread local storage and no unique id.</td><td>Thread have thread local storage and have unique id.</td></tr><tr><td>Scheduling</td><td>Goroutines are co-operatively scheduled.</td><td>Threads are preemptively scheduled.</td></tr><tr><td>Startup</td><td>Goroutines have faster startup time.</td><td>Threads have slower startup time.</td></tr><tr><td>Stack</td><td>Goroutines have growable segmented stacks.</td><td>Threads do not have growable segmented stacks.</td></tr></tbody></table><p>Imagine, you have a web server, this server is handling 1000 requests per second. If an OS thread consume 1MB stack size per thread, that means it takes 1GB of RAM for that traffic.</p><p>In case of goroutines, since stack size can grow dynamically, you can spawn 1000 goroutines without problems. As a goroutine starts with 8KB, most of them generally do not grow bigger than that</p><h3 id=goroutine>Goroutine<a hidden class=anchor aria-hidden=true href=#goroutine>#</a></h3><p>The number of CPUs available simultaneously to executing goroutines is controlled by the GOMAXPROCS shell environment variable, whose default value is the number of CPU cores available (<a href=#2>2</a>)</p><h4 id=basic-syntax>Basic syntax<a hidden class=anchor aria-hidden=true href=#basic-syntax>#</a></h4><p>Goroutine in a loop</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#66d9ef>go</span> println(<span style=color:#a6e22e>i</span>)
	}
  <span style=color:#75715e>//Wait for all goroutine done before main terminated
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>) 
}

</code></pre></div><p>Output</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#ae81ff>1</span>
<span style=color:#ae81ff>9</span>
<span style=color:#ae81ff>2</span>
<span style=color:#ae81ff>3</span>
<span style=color:#ae81ff>4</span>
<span style=color:#ae81ff>5</span>
<span style=color:#ae81ff>6</span>
<span style=color:#ae81ff>8</span>
<span style=color:#ae81ff>0</span>
<span style=color:#ae81ff>7</span>
</code></pre></div><h4 id=goroutine-under-the-hood>Goroutine under the hood<a hidden class=anchor aria-hidden=true href=#goroutine-under-the-hood>#</a></h4><ul><li><p>When initialize a goroutine, it uses stacks. It provides a few KBs of stack RAM, which is almost always enough. This amount of RAM is based on strategy of Golang, for example (<a href=#3>3</a>):</p><ul><li>Go 1.2: goroutine stack has been increased from 4Kb to 8Kb.</li><li>Go 1.4: goroutine stack has decreased from 8Kb to 2Kb.</li></ul></li><li><p>When <strong>goroutine size overflow</strong> the init size. Runtime Golang has some methods for stack management:</p><ul><li>Segmented stacks<ul><li>Example, we have stack S1 is currently init by a goroutine G1. If the stack S1 is almost full, a call will force a new stack chunk to be allocated.<br><img src=https://raw.githubusercontent.com/sdt-research-team/sdt-research-team.github.io/main/blog/static/images/stack-segment-01.png alt=stack-segment-01.png></li><li><strong>Problem</strong>: This approach can become hell if the stack is almost full in a loop, it will create multiple useless segments.</li></ul></li><li>Stack copying<ul><li>Example, we have stack S1 is currently init by a goroutine G1. If the stack S1 is almost full, it will allocate another stack S2 and copy all S1 data to S2 (S1 will be cleaning up later by garbage collector)<br><img src=https://raw.githubusercontent.com/sdt-research-team/sdt-research-team.github.io/main/blog/static/images/stack-copy-01.png alt=stack-copy-01.png></li></ul></li></ul></li></ul><h4 id=why-goroutines-instead-of-threads>Why goroutines instead of threads?<a hidden class=anchor aria-hidden=true href=#why-goroutines-instead-of-threads>#</a></h4><h3 id=wait-group>Wait group<a hidden class=anchor aria-hidden=true href=#wait-group>#</a></h3><h4 id=basic-syntax-1>Basic syntax<a hidden class=anchor aria-hidden=true href=#basic-syntax-1>#</a></h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>worker</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>) {

    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>() <span style=color:#75715e>//Decrease counter by one
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Worker %d starting\n&#34;</span>, <span style=color:#a6e22e>id</span>)

    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Worker %d done\n&#34;</span>, <span style=color:#a6e22e>id</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>

    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>5</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>) <span style=color:#75715e>//Increase counter by one
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>worker</span>(<span style=color:#a6e22e>i</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>wg</span>)
    }

    <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>() <span style=color:#75715e>//Wait for counter until zero
</span><span style=color:#75715e></span>}
</code></pre></div><h4 id=waitgroup-and-concurrency>WaitGroup and concurrency<a hidden class=anchor aria-hidden=true href=#waitgroup-and-concurrency>#</a></h4><p>WaitGroup is independent with concurrency programing. Because you can use it without any goroutines. Example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>waitGroupWithoutGoroutine</span>() {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> = <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>{}
	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>5</span>)

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>5</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Doing task #&#34;</span>, <span style=color:#a6e22e>i</span>)
		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
	}

	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
}
</code></pre></div><p>But WaitGroup is developed for concurrency. The type <strong>WaitGroup</strong> is in package <em>sync</em> which is provides basic synchronization primitives (thread or process synchronization frameworks).</p><h4 id=waitgroup-specifications>WaitGroup specifications:<a hidden class=anchor aria-hidden=true href=#waitgroup-specifications>#</a></h4><ul><li>Should not be copied. When passing a wait group variable to a goroutine function, it should be passed by pointer reference.</li><li>Use stack pointer to store counter value.</li></ul><h3 id=channel>Channel<a hidden class=anchor aria-hidden=true href=#channel>#</a></h3><h3 id=worker-pool>Worker pool<a hidden class=anchor aria-hidden=true href=#worker-pool>#</a></h3><h3 id=rate-limit>Rate Limit<a hidden class=anchor aria-hidden=true href=#rate-limit>#</a></h3><h3 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h3><h4 id=1>(1)<a hidden class=anchor aria-hidden=true href=#1>#</a></h4><p><a href=https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes>https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes</a></p><h4 id=2>(2)<a hidden class=anchor aria-hidden=true href=#2>#</a></h4><p><a href=https://golang.org/doc/faq#number_cpus>https://golang.org/doc/faq#number_cpus</a></p><h4 id=3>(3)<a hidden class=anchor aria-hidden=true href=#3>#</a></h4><p><a href=https://medium.com/a-journey-with-go/go-how-does-the-goroutine-stack-size-evolve-447fc02085e5>https://medium.com/a-journey-with-go/go-how-does-the-goroutine-stack-size-evolve-447fc02085e5</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sdt-research-team.github.io/tags/go/>go</a></li><li><a href=https://sdt-research-team.github.io/tags/operating-system/>operating system</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Go Concurrency on twitter" href="https://twitter.com/intent/tweet/?text=Go%20Concurrency&url=https%3a%2f%2fsdt-research-team.github.io%2fposts%2fgo-concurrency%2f&hashtags=go%2coperatingsystem"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go Concurrency on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fsdt-research-team.github.io%2fposts%2fgo-concurrency%2f&title=Go%20Concurrency&summary=Go%20Concurrency&source=https%3a%2f%2fsdt-research-team.github.io%2fposts%2fgo-concurrency%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go Concurrency on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsdt-research-team.github.io%2fposts%2fgo-concurrency%2f&title=Go%20Concurrency"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go Concurrency on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsdt-research-team.github.io%2fposts%2fgo-concurrency%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go Concurrency on whatsapp" href="https://api.whatsapp.com/send?text=Go%20Concurrency%20-%20https%3a%2f%2fsdt-research-team.github.io%2fposts%2fgo-concurrency%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Go Concurrency on telegram" href="https://telegram.me/share/url?text=Go%20Concurrency&url=https%3a%2f%2fsdt-research-team.github.io%2fposts%2fgo-concurrency%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://sdt-research-team.github.io>Research Team</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><button class=top-link id=top-link type=button aria-label="go to top" title="Go to Top (Alt + G)" accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button>
<script defer src=https://sdt-research-team.github.io/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};mybutton.onclick=function(){document.body.scrollTop=0;document.documentElement.scrollTop=0;window.location.hash=''}
function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>