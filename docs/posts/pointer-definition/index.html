<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Pointer Definition | Research Team</title><meta name=keywords content="go"><meta name=description content="Pointers Variable Variable (hay còn gọi là biến) là một ô nhớ đơn lẻ hoặc một vùng nhớ được hệ điều hành cấp phát cho chương trình Go nhằm để lưu trữ giá trị vào bên trong vùng nhớ đó. Để truy xuất đến giá trị mà biến đang nắm giữ, chương trình cần tìm đến vùng nhớ (địa chỉ) của biến để đọc giá trị bên trong vùng nhớ đó, cũng như bạn muốn lấy món đồ bên trong cái hộp, bạn cần biết cái hộp được đặt ở đâu."><meta name=author content="Pham Minh Toan"><link rel=canonical href=https://sdt-research-team.github.io/posts/pointer-definition/><meta name=google-site-verification content="XYZabc"><link href=https://sdt-research-team.github.io/assets/css/stylesheet.min.d1bc2b736056bd5698d770eeedc08a73bce9e6cebb30810f6f1b2c2048e46ab8.css integrity="sha256-0bwrc2BWvVaY13Du7cCKc7zp5s67MIEPbxssIEjkarg=" rel="preload stylesheet" as=style><link rel=icon href=https://sdt-research-team.github.io/%3Cpath%20/%20external%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://sdt-research-team.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sdt-research-team.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://sdt-research-team.github.io/apple-touch-icon.png><link rel=mask-icon href=https://sdt-research-team.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.1"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-123-45','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Pointer Definition"><meta property="og:description" content="Pointers Variable Variable (hay còn gọi là biến) là một ô nhớ đơn lẻ hoặc một vùng nhớ được hệ điều hành cấp phát cho chương trình Go nhằm để lưu trữ giá trị vào bên trong vùng nhớ đó. Để truy xuất đến giá trị mà biến đang nắm giữ, chương trình cần tìm đến vùng nhớ (địa chỉ) của biến để đọc giá trị bên trong vùng nhớ đó, cũng như bạn muốn lấy món đồ bên trong cái hộp, bạn cần biết cái hộp được đặt ở đâu."><meta property="og:type" content="article"><meta property="og:url" content="https://sdt-research-team.github.io/posts/pointer-definition/"><meta property="og:image" content="https://sdt-research-team.github.io/60"><meta property="article:published_time" content="2020-12-18T09:57:01+07:00"><meta property="article:modified_time" content="2020-12-18T09:57:01+07:00"><meta property="og:site_name" content="Research Team"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sdt-research-team.github.io/60"><meta name=twitter:title content="Pointer Definition"><meta name=twitter:description content="Pointers Variable Variable (hay còn gọi là biến) là một ô nhớ đơn lẻ hoặc một vùng nhớ được hệ điều hành cấp phát cho chương trình Go nhằm để lưu trữ giá trị vào bên trong vùng nhớ đó. Để truy xuất đến giá trị mà biến đang nắm giữ, chương trình cần tìm đến vùng nhớ (địa chỉ) của biến để đọc giá trị bên trong vùng nhớ đó, cũng như bạn muốn lấy món đồ bên trong cái hộp, bạn cần biết cái hộp được đặt ở đâu."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Pointer Definition","name":"Pointer Definition","description":"Pointers Variable Variable (hay còn gọi là biến) là một ô nhớ đơn lẻ hoặc một vùng nhớ được hệ điều hành cấp phát cho chương trình Go nhằm để lưu trữ giá trị vào bên trong vùng nhớ …","keywords":["go"],"articleBody":"Pointers Variable Variable (hay còn gọi là biến) là một ô nhớ đơn lẻ hoặc một vùng nhớ được hệ điều hành cấp phát cho chương trình Go nhằm để lưu trữ giá trị vào bên trong vùng nhớ đó. Để truy xuất đến giá trị mà biến đang nắm giữ, chương trình cần tìm đến vùng nhớ (địa chỉ) của biến để đọc giá trị bên trong vùng nhớ đó, cũng như bạn muốn lấy món đồ bên trong cái hộp, bạn cần biết cái hộp được đặt ở đâu. Khi thao tác với các biến thông thường, chúng ta không cần quan tâm đến địa chỉ vùng nhớ của biến. Khi cần truy xuất giá trị của biến, chúng ta chỉ cần gọi định danh (hay thường gọi là tên biến).\nVí dụ: int16 money; Khi dòng lệnh này được CPU thực thi, một vùng nhớ có kích thước 2 bytes sẽ được cấp phát. Lấy ví dụ biến money này được đặt tại ô nhớ 1224 (trong địa chỉ ảo của máy tính). ￼ Bất cứ khi nào chương trình thấy các bạn sử dụng biến money trong câu lệnh, chương trình hiểu rằng cần tìm đến ô nhớ 1224 để lấy giá trị đó ra.\nVirtual memory \u0026 Physical memory Việc truy xuất dữ liệu trên bộ nhớ máy tính cần phải thông qua một số bước trung gian, người dùng không thể trực tiếp truy xuất vào các ô nhớ trên các thiết bị lưu trữ. Chúng ta chỉ có thể trỏ đến vùng nhớ ảo (virtual memory) trên máy tính, còn việc truy xuất đến bộ nhớ vật lý (physical memory) từ bộ nhớ ảo phải được thực hiện bởi thiết bị phần cứng có tên là Memory management unit (MMU) và một chương trình định vị địa chỉ bộ nhớ gọi là Virtual address space. ￼\nVirtual memory làm che giấu sự phân mảnh của bộ nhớ vật lý, khiến chúng ta có cảm giác đang thao tác với các vùng nhớ liên tục. Trong hình trên, từ phía Virtual memory cho đến Physical memory thuộc về phần quản lý của hệ điều hành, lập trình viên và người dùng chúng ta không thể can thiệp trực tiếp đến trong quá trình máy tính đang hoạt động.\nVariable address \u0026 address-of operator Địa chỉ của biến mà chúng ta nhìn thấy thật ra chỉ là những giá trị đã được đánh số thứ tự đặt trên Virtual memory. Để lấy được địa chỉ ảo của biến trong chương trình, chúng ta sử dụng toán tử ‘\u0026’ đặt trước tên biến.\nvar x int = 5; fmt.Println(x) // print the value of variable x fmt.Println(\u0026x) / print the memory address of variable x Trên máy tính của mình, kết quả của đoạn chương trình trên được in ra như sau:\n5 0027FEA0 Dòng đầu tiên là kết quả của việc truy xuất giá trị của biến thông qua định danh (tên biến). Dòng thứ hai là kết quả của việc truy xuất đến địa chỉ ảo của biến.\nDereference operator Toán tử trỏ đến (dereference operator) hay còn gọi là indirection operator (toán tử điều hành gián tiếp) được kí hiệu bằng dấu sao \" * \" cho phép chúng ta lấy ra giá trị của vùng nhớ có địa chỉ cụ thể. Ví dụ:\nvar n int = 5 fmt.Println(n) //print the value of variable n fmt.Println(\u0026n) //print the virtual memory address of variable n fmt.Println(*(\u0026n)) //print the value at the virtual memory address of variable n  Dòng lệnh đầu tiên khá dễ hiểu, nó thực hiện in ra giá trị của biến n bằng cách gọi định danh n, còn lại phần truy xuất đến địa chỉ ảo của biến n sẽ do chương trình đảm nhiệm. Dòng lệnh thứ hai không dùng để lấy ra giá trị bên trong vùng nhớ mà biến n đang nắm giữ, mà nó lấy ra địa chỉ ảo của biến n. Dòng lệnh thứ ba chúng ta sử dụng toán tử trỏ đến \" * \" đặt trước toán tử address-of. Khi đó, (\u0026n) sẽ lấy ra địa chỉ ảo của biến n, và toán tử * sẽ truy xuất giá trị bên trong địa chỉ đó. Kết quả của đoạn chương trình trên là:  5 0xBFD181AC 5 Ngoài việc truy xuất giá trị trong vùng nhớ của một địa chỉ cụ thể, toán tử trỏ đến (dereference operator) còn có thể dùng để thay đổi giá trị bên trong vùng nhớ đó.\nvar n int = 5 fmt.Println(n) *n = 10 fmt.Println(n) Kết quả đoạn chương trình này là:\n5 10 Như vậy, dereference operator cho phép chúng ta thao tác trực tiếp trên Virtual memory mà không cần thông qua định danh (tên biến). Mặc dù dereference operator có kí hiệu giống multiplication operator, nhưng các bạn có thể phân biệt được vì dereference operator là toán tử một ngôi, trong khi đó, multiplication operator là toán tử hai ngôi. Khác với tham chiếu (reference), toán tử trỏ đến (dereference operator) không tạo ra một tên biến khác, mà nó truy xuất trực tiếp đến vùng nhớ có địa chỉ cụ thể trên Virtual memory.\nCon trỏ (Pointer) Với những khái niệm mình trình bày ở trên (một số khái niệm các bạn đã được học), bây giờ chúng ta có thể nói đến con trỏ (pointer). Một con trỏ (a pointer) là một biến được dùng để lưu trữ địa chỉ của biến khác. con trỏ là một biến có địa chỉ độc lập so với vùng nhớ mà nó trỏ đến, nhưng giá trị bên trong vùng nhớ của con trỏ chính là địa chỉ của biến (hoặc địa chỉ ảo) mà nó trỏ tới. ￼\nTrong ví dụ trên, một con trỏ sau khi khai báo đã được cấp phát vùng nhớ tại địa chỉ 3255, và nó trỏ đến địa chỉ 1224, do đó, giá trị bên trong vùng nhớ của con trỏ là 1224.\nKhai báo con trỏ Cũng giống như biến thông thường, biến con trỏ cần được khai báo trước khi sử dụng. Con trỏ yêu cầu cú pháp khai báo mới hơn một chút so với biến thông thường. var  *; Khác với biến thông thường, chúng ta cần đặt thêm dấu sao giữa tên biến và kiểu dữ liệu của con trỏ. Ví dụ:\nvar p *int var pt *string Lưu ý: Dấu sao trong khai báo con trỏ không phải là toán tử trỏ đến (dereference operator), nó chỉ là cú pháp được ngôn ngữ Golang quy định.\n Kiểu dữ liệu của con trỏ không mô tả giá trị địa chỉ được lưu trữ bên trong con trỏ, mà kiểu dữ liệu của con trỏ dùng để xác định kiểu dữ liệu của biến mà nó trỏ đến trên bộ nhớ ảo.  Hãy xem đoạn code sau:\nfunc main() { // declare an int value and an int pointer \tvar ival int = 1 var iptr *int = \u0026ival // declare a float value and a float pointer \tvar fval float32 = 1.0 var fptr *float32 = \u0026fval // declare a char value and a char pointer \tvar sval string = \"\" var sptr *string = \u0026sval // can't do this, doesn't make sense \t// iptr = \u0026fval; \t// fptr = \u0026ival; \t// iptr = \u0026sval; } Khi chúng ta định nghĩa một pointer kiểu int, chúng ta định nghĩa biến đó là 1 pointer, biến đó giữ địa chỉ tới một biến khác, và giá trị ở tại địa chỉ đó là 1 số nguyên int. Tương tự đối với float pointer, char pointer, hay bất cứ kiểu nào khác. Định nghĩa một pointer thuộc một kiểu xác định sẽ giúp cho trình biên dịch biết rằng khi chúng ta tham chiếu ngược tới một pointer đó thì nó sẽ trỏ đến giá trị thuộc kiểu nào. Bạn sẽ thấy rằng trong ví dụ trên, chúng ta định nghĩa ra pointer thuộc một kiểu nào đó và gán địa chỉ của một giá trị thuộc cùng kiểu. Nếu bạn bỏ comment mấy dòng cuối và thử compile nó thì sẽ bị lỗi “assignment from incompatible pointer type” (gán giá trị sai kiểu) và code không thể compile được. Bạn chỉ có thể gán địa chỉ của một giá trị cho pointer cùng kiểu với nó. Toán tử \u0026 trả về một pointer thuộc kiểu của biến mà nó đứng trước. Trong đoạn code trên \u0026ival trả về một pointer thuộc kiểu int, fval trả về một pointer thuộc kiểu float và \u0026sval trả về pointer thuộc kiểu string. Những chỗ nào mà bạn có thể dùng pointer thì cũng có thể sử dụng một biến \u0026val tương ứng.\n Phép gán của con trỏ chỉ thực hiện được khi kiểu dữ liệu của con trỏ phù hợp kiểu dữ liệu của biến mà nó sẽ trỏ tới.  Gán giá trị cho con trỏ Giá trị mà biến con trỏ lưu trữ là địa chỉ của biến khác có cùng kiểu dữ liệu với biến con trỏ.\nvar ptr *int; var value int = 5; ptr = \u0026value; Do đó, chúng ta cần sử dụng address-of operator để lấy ra địa chỉ ảo của biến rồi mới gán cho con trỏ được. Lúc này, biến ptr sẽ lưu trữ địa chỉ ảo của biến value. ￼\nChúng ta có thể nói rằng con trỏ ptr đang nắm giữ địa chỉ của biến value, cũng có thể nói con trỏ ptr trỏ đến biến value. Đoạn chương trình sau sẽ in ra địa chỉ của biến value và giá trị được lưu bởi con trỏ ptr sau khi trỏ đến biến value:\nfunc main() { var value int = 5; var ptr *int = \u0026value; fmt.Println(\u0026value) fmt.Println(ptr) } Kết quả thu được trên màn hình console:\n0012FF7C 0012FF7C Lý do mà chúng ta gán được địa chỉ của biến value cho con trỏ kiểu int (int *) là vì address-of operator của một biến kiểu int trả về giá trị kiểu con trỏ kiểu int (int *). Do đó, chúng ta có thể gán \u0026value cho con trỏ kiểu int (int *).\nBên cạnh đó, khi có hai con trỏ cùng kiểu thì chúng ta có thể gán trực tiếp mà không cần sử dụng address-of operator.\nint main() { int value = 5 var ptr1, ptr2 int ptr1 = \u0026value; //ptr1 point to value \tptr2 = ptr1; //assign value of ptr1 to ptr2  fmt.Println(ptr1) fmt.Println(ptr2) } Lúc này, ptr1 và ptr2 cùng giữ địa chỉ của biến value.\nTruy xuất giá trị bên trong vùng nhớ mà con trỏ trỏ đến Khi chúng ta có một con trỏ đã được trỏ đến địa chỉ nào đó trong bộ nhớ ảo, chúng ta có thể truy xuất giá trị tại địa chỉ đó bằng dereference operator. Dereference operator sẽ đánh giá nội dung địa chỉ được trỏ đến.\nvar ptr *int *ptr //declare an int pointer var value int = 5 ptr = \u0026value //ptr point to value  fmt.Println(value) //print the address of value fmt.Println(ptr) //print the address of value which is held in ptr  fmt.Println(value) //print the content of value fmt.Println(*(\u0026value)) //print the content of value fmt.Println(*ptr)\t//print the content of value Kết quả của đoạn chương trình trên như sau:\n￼ Toán tử trỏ đến (dereference operator) được dùng để truy cập trực tiếp vào vùng nhớ có địa chỉ cụ thể trên bộ nhớ ảo (virtual memory), vì biến con trỏ ptr đang giữ địa chỉ của biến value nên khi đặt toán tử trỏ đến (dereference operator) trước con trỏ ptr, nó sẽ truy xuất giá trị tại địa chỉ mà con trỏ ptr đang giữ. Vì ptr có kiểu dữ liệu con trỏ int (int *), ptr chỉ có thể trỏ đến biến kiểu int. Lúc này, compiler hiểu rằng cần phân tích 4 bytes (đúng bằng kích thước kiểu int) trên bộ nhớ ảo tại địa chỉ mà ptr đang lưu trữ. ￼\nĐây là lý do tại sao chúng ta cần khai báo kiểu dữ liệu của con trỏ. Nếu không khai báo kiểu dữ liệu cho con trỏ, toán tử trỏ đến (dereference operator) sẽ không biết phải phân tích bao nhiêu bytes tại địa chỉ con trỏ trỏ đến để tính toán được giá trị của vùng nhớ đó. Không những thế, đây còn là lý do kiểu dữ liệu của biến phải tương xứng với kiểu dữ liệu được khai báo cho con trỏ. Vì chúng ta có thể gán lại địa chỉ mới cho một con trỏ, nên chúng ta có thể truy xuất được giá trị của nhiều vùng nhớ khác nhau chỉ với một con trỏ:\nvar value1 int = 1 var value2 int = 2 var ptr *int = \u0026value1 fmt.Println(*ptr) ptr = \u0026value2 fmt.Println(*ptr) Với khả năng truy cập đến vùng nhớ có địa chỉ cụ thể và thay đổi giá trị bên trong vùng nhớ của toán tử trỏ đến (dereference operator), chúng ta có thể sử dụng như sau:\nvar value int = 5 var ptr *int = \u0026value *ptr = 10 fmt.Println(*ptr) Đoạn chương trình này sẽ in ra giá trị 10. Có thể giải thích dòng lệnh *ptr = 10; như sau: Biến con trỏ ptr sau khi khai báo đã được khởi tạo bằng cách gán địa chỉ của biến value. Sử dụng dereference operator cho con trỏ ptr để truy cập đến địa chỉ ảo mà ptr đang nắm giữ, gán giá trị 10 vào vùng nhớ tại vị trí đó.\nCon trỏ chưa được gán địa chỉ Con trỏ trong ngôn ngữ Golang vốn có rủi ro. Nếu sử dụng con trỏ không hợp lý có thể gây panic chương trình. Khác với tham chiếu (reference), biến con trỏ có thể không cần khởi tạo giá trị ngay khi khai báo. Nhưng thực hiện truy xuất giá trị của con trỏ bằng dereference operator khi chưa gán địa chỉ cụ thể cho con trỏ, chương trình có thể bị đóng bởi hệ điều hành. Nguyên nhân là cố gắng đọc một con trỏ nil. Đối với con trỏ, Nil là một giá trị đặc biệt (Zero Value), khi gán Nil cho con trỏ, điều đó có nghĩa là con trỏ đó chưa trỏ đến địa chỉ nào cả. Con trỏ đang giữ giá trị Nil được gọi là con trỏ Nil (Nil pointer).\nTổng kết Trong bài học này, các bạn đã được tìm hiểu khái niệm con trỏ và một số khái niệm có liên quan. Việc sử dụng con trỏ thường có một số hoạt động chủ yếu:\n khai báo một con trỏ. gán địa chỉ cho con trỏ. truy cập đến địa chỉ mà con trỏ đang nắm giữ bằng dereference operator.  Thử liên hệ một chút với cuộc sống thực tế, tưởng tượng rằng con đường nhà bạn (street) là bộ nhớ ảo, trên con đường đó có rất nhiều ngôi nhà (house), mỗi ngôi nhà đều được đánh số thứ tự gọi là địa chỉ nhà (house’s address). Chúng ta tạm hình dung số người ở trong mỗi ngôi nhà (content) tương đương với nội dung của mỗi ô trên bộ nhớ ảo.\nNhư vậy, address-of operator (\u0026house) sẽ trả về địa chỉ của ngôi nhà, dereference operator (*\u0026house) sẽ lấy ra số lượng người bên trong ngôi nhà có địa chỉ được xác định. Để sử dụng con trỏ trỏ đến mỗi ngôi nhà, chúng ta phải sử dụng một con trỏ kiểu House (giống với kiểu của từng ngôi nhà), giả sử con trỏ kiểu House được khai báo là House *h_ptr; thì con trỏ h_ptr có thể trỏ đến bất kì ngôi nhà nào trên con đường, và nó còn có thể thay đổi nội dung bên trong từng ngôi nhà mà nó trỏ đến.\nCon trỏ (Pointer) là một công cụ mạnh mẽ đặc trưng của ngôn ngữ Golang. Con trỏ cho phép chúng ta chia sẻ data của chương trình trên bộ nhớ ảo.\n- Pham Minh Toan -\n","wordCount":"2697","inLanguage":"en","datePublished":"2020-12-18T09:57:01+07:00","dateModified":"2020-12-18T09:57:01+07:00","author":{"@type":"Person","name":"Pham Minh Toan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sdt-research-team.github.io/posts/pointer-definition/"},"publisher":{"@type":"Organization","name":"Research Team","logo":{"@type":"ImageObject","url":"https://sdt-research-team.github.io/%3Cpath%20/%20external%20url%3E"}}}</script></head><body><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://sdt-research-team.github.io accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://sdt-research-team.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://sdt-research-team.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Pointer Definition</h1><div class=post-meta>December 18, 2020&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Pham Minh Toan</div></header><div class=post-content><h1 id=pointers>Pointers<a hidden class=anchor aria-hidden=true href=#pointers>#</a></h1><h2 id=variable>Variable<a hidden class=anchor aria-hidden=true href=#variable>#</a></h2><p>Variable (hay còn gọi là biến) là một ô nhớ đơn lẻ hoặc một vùng nhớ được hệ điều hành cấp phát cho chương trình Go nhằm để lưu trữ giá trị vào bên trong vùng nhớ đó. Để truy xuất đến giá trị mà biến đang nắm giữ, chương trình cần tìm đến vùng nhớ (địa chỉ) của biến để đọc giá trị bên trong vùng nhớ đó, cũng như bạn muốn lấy món đồ bên trong cái hộp, bạn cần biết cái hộp được đặt ở đâu.
Khi thao tác với các biến thông thường, chúng ta không cần quan tâm đến địa chỉ vùng nhớ của biến. Khi cần truy xuất giá trị của biến, chúng ta chỉ cần gọi định danh (hay thường gọi là tên biến).</p><p>Ví dụ:
int16 money;
Khi dòng lệnh này được CPU thực thi, một vùng nhớ có kích thước 2 bytes sẽ được cấp phát. Lấy ví dụ biến money này được đặt tại ô nhớ 1224 (trong địa chỉ ảo của máy tính).
<img src=https://raw.githubusercontent.com/sendo-research-team/sendo-research-team.github.io/gh-pages/static/images/1.JPG alt="Image 1">
￼
Bất cứ khi nào chương trình thấy các bạn sử dụng biến money trong câu lệnh, chương trình hiểu rằng cần tìm đến ô nhớ 1224 để lấy giá trị đó ra.</p><h2 id=virtual-memory--physical-memory>Virtual memory & Physical memory<a hidden class=anchor aria-hidden=true href=#virtual-memory--physical-memory>#</a></h2><p>Việc truy xuất dữ liệu trên bộ nhớ máy tính cần phải thông qua một số bước trung gian, người dùng không thể trực tiếp truy xuất vào các ô nhớ trên các thiết bị lưu trữ. Chúng ta chỉ có thể trỏ đến vùng nhớ ảo (virtual memory) trên máy tính, còn việc truy xuất đến bộ nhớ vật lý (physical memory) từ bộ nhớ ảo phải được thực hiện bởi thiết bị phần cứng có tên là Memory management unit (MMU) và một chương trình định vị địa chỉ bộ nhớ gọi là Virtual address space.
<img src=https://raw.githubusercontent.com/sendo-research-team/sendo-research-team.github.io/gh-pages/static/images/2.JPG alt="Image 2">
￼</p><p>Virtual memory làm che giấu sự phân mảnh của bộ nhớ vật lý, khiến chúng ta có cảm giác đang thao tác với các vùng nhớ liên tục. Trong hình trên, từ phía Virtual memory cho đến Physical memory thuộc về phần quản lý của hệ điều hành, lập trình viên và người dùng chúng ta không thể can thiệp trực tiếp đến trong quá trình máy tính đang hoạt động.</p><h2 id=variable-address--address-of-operator>Variable address & address-of operator<a hidden class=anchor aria-hidden=true href=#variable-address--address-of-operator>#</a></h2><p>Địa chỉ của biến mà chúng ta nhìn thấy thật ra chỉ là những giá trị đã được đánh số thứ tự đặt trên Virtual memory. Để lấy được địa chỉ ảo của biến trong chương trình, chúng ta sử dụng toán tử &lsquo;&&rsquo; đặt trước tên biến.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>5</span>;
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>) <span style=color:#75715e>// print the value of variable x
</span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>x</span>) <span style=color:#f92672>/</span> <span style=color:#a6e22e>print</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>memory</span> <span style=color:#a6e22e>address</span> <span style=color:#a6e22e>of</span> <span style=color:#a6e22e>variable</span> <span style=color:#a6e22e>x</span>
</code></pre></div><p>Trên máy tính của mình, kết quả của đoạn chương trình trên được in ra như sau:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#ae81ff>5</span>
<span style=color:#ae81ff>0027</span><span style=color:#a6e22e>FEA0</span>
</code></pre></div><p>Dòng đầu tiên là kết quả của việc truy xuất giá trị của biến thông qua định danh (tên biến). Dòng thứ hai là kết quả của việc truy xuất đến địa chỉ ảo của biến.</p><p>Dereference operator
Toán tử trỏ đến (dereference operator) hay còn gọi là indirection operator (toán tử điều hành gián tiếp) được kí hiệu bằng dấu sao " * " cho phép chúng ta lấy ra giá trị của vùng nhớ có địa chỉ cụ thể.
Ví dụ:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>5</span>

<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>n</span>)   <span style=color:#75715e>//print the value of variable n
</span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>n</span>)   <span style=color:#75715e>//print the virtual memory address of variable n
</span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>*</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>n</span>)) <span style=color:#75715e>//print the value at the virtual memory address of variable n
</span></code></pre></div><ul><li>Dòng lệnh đầu tiên khá dễ hiểu, nó thực hiện in ra giá trị của biến n bằng cách gọi định danh n, còn lại phần truy xuất đến địa chỉ ảo của biến n sẽ do chương trình đảm nhiệm.</li><li>Dòng lệnh thứ hai không dùng để lấy ra giá trị bên trong vùng nhớ mà biến n đang nắm giữ, mà nó lấy ra địa chỉ ảo của biến n.</li><li>Dòng lệnh thứ ba chúng ta sử dụng toán tử trỏ đến " * " đặt trước toán tử address-of. Khi đó, (&n) sẽ lấy ra địa chỉ ảo của biến n, và toán tử * sẽ truy xuất giá trị bên trong địa chỉ đó.
Kết quả của đoạn chương trình trên là:</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#ae81ff>5</span>
<span style=color:#ae81ff>0xBFD181AC</span>
<span style=color:#ae81ff>5</span>
</code></pre></div><p>Ngoài việc truy xuất giá trị trong vùng nhớ của một địa chỉ cụ thể, toán tử trỏ đến (dereference operator) còn có thể dùng để thay đổi giá trị bên trong vùng nhớ đó.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>5</span>
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>n</span>)
<span style=color:#f92672>*</span><span style=color:#a6e22e>n</span> = <span style=color:#ae81ff>10</span>
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>n</span>)
</code></pre></div><p>Kết quả đoạn chương trình này là:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#ae81ff>5</span>
<span style=color:#ae81ff>10</span>
</code></pre></div><p>Như vậy, dereference operator cho phép chúng ta thao tác trực tiếp trên Virtual memory mà không cần thông qua định danh (tên biến).
<img src=https://raw.githubusercontent.com/sendo-research-team/sendo-research-team.github.io/gh-pages/static/images/3.JPG alt="Image 3"></p><p>Mặc dù dereference operator có kí hiệu giống multiplication operator, nhưng các bạn có thể phân biệt được vì dereference operator là toán tử một ngôi, trong khi đó, multiplication operator là toán tử hai ngôi.
Khác với tham chiếu (reference), toán tử trỏ đến (dereference operator) không tạo ra một tên biến khác, mà nó truy xuất trực tiếp đến vùng nhớ có địa chỉ cụ thể trên Virtual memory.</p><h2 id=con-trỏ-pointer>Con trỏ (Pointer)<a hidden class=anchor aria-hidden=true href=#con-trỏ-pointer>#</a></h2><p>Với những khái niệm mình trình bày ở trên (một số khái niệm các bạn đã được học), bây giờ chúng ta có thể nói đến con trỏ (pointer).
Một con trỏ (a pointer) là một biến được dùng để lưu trữ địa chỉ của biến khác.
con trỏ là một biến có địa chỉ độc lập so với vùng nhớ mà nó trỏ đến, nhưng giá trị bên trong vùng nhớ của con trỏ chính là địa chỉ của biến (hoặc địa chỉ ảo) mà nó trỏ tới.
<img src=https://raw.githubusercontent.com/sendo-research-team/sendo-research-team.github.io/gh-pages/static/images/4.JPG alt="Image 4">
￼</p><p>Trong ví dụ trên, một con trỏ sau khi khai báo đã được cấp phát vùng nhớ tại địa chỉ 3255, và nó trỏ đến địa chỉ 1224, do đó, giá trị bên trong vùng nhớ của con trỏ là 1224.</p><h2 id=khai-báo-con-trỏ>Khai báo con trỏ<a hidden class=anchor aria-hidden=true href=#khai-báo-con-trỏ>#</a></h2><p>Cũng giống như biến thông thường, biến con trỏ cần được khai báo trước khi sử dụng. Con trỏ yêu cầu cú pháp khai báo mới hơn một chút so với biến thông thường.
var &lt;name_of_pointer> *&lt;data_type>;
Khác với biến thông thường, chúng ta cần đặt thêm dấu sao giữa tên biến và kiểu dữ liệu của con trỏ.
Ví dụ:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>pt</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>string</span>
</code></pre></div><p>Lưu ý: Dấu sao trong khai báo con trỏ không phải là toán tử trỏ đến (dereference operator), nó chỉ là cú pháp được ngôn ngữ Golang quy định.</p><ul><li>Kiểu dữ liệu của con trỏ không mô tả giá trị địa chỉ được lưu trữ bên trong con trỏ, mà kiểu dữ liệu của con trỏ dùng để xác định kiểu dữ liệu của biến mà nó trỏ đến trên bộ nhớ ảo.</li></ul><p>Hãy xem đoạn code sau:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#75715e>// declare an int value and an int pointer
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ival</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>1</span>

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>iptr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ival</span>

	<span style=color:#75715e>// declare a float value and a float pointer
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fval</span> <span style=color:#66d9ef>float32</span> = <span style=color:#ae81ff>1.0</span>

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fptr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>float32</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>fval</span>

	<span style=color:#75715e>// declare a char value and a char pointer
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sval</span> <span style=color:#66d9ef>string</span> = <span style=color:#e6db74>&#34;&#34;</span>

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sptr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>string</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sval</span>

	<span style=color:#75715e>// can&#39;t do this, doesn&#39;t make sense
</span><span style=color:#75715e></span>	<span style=color:#75715e>// iptr = &amp;fval;
</span><span style=color:#75715e></span>	<span style=color:#75715e>// fptr = &amp;ival;
</span><span style=color:#75715e></span>	<span style=color:#75715e>// iptr = &amp;sval;
</span><span style=color:#75715e></span>}
</code></pre></div><p>Khi chúng ta định nghĩa một pointer kiểu int, chúng ta định nghĩa biến đó là 1 pointer, biến đó giữ địa chỉ tới một biến khác, và giá trị ở tại địa chỉ đó là 1 số nguyên int. Tương tự đối với float pointer, char pointer, hay bất cứ kiểu nào khác. Định nghĩa một pointer thuộc một kiểu xác định sẽ giúp cho trình biên dịch biết rằng khi chúng ta tham chiếu ngược tới một pointer đó thì nó sẽ trỏ đến giá trị thuộc kiểu nào.
Bạn sẽ thấy rằng trong ví dụ trên, chúng ta định nghĩa ra pointer thuộc một kiểu nào đó và gán địa chỉ của một giá trị thuộc cùng kiểu. Nếu bạn bỏ comment mấy dòng cuối và thử compile nó thì sẽ bị lỗi “assignment from incompatible pointer type” (gán giá trị sai kiểu) và code không thể compile được. Bạn chỉ có thể gán địa chỉ của một giá trị cho pointer cùng kiểu với nó.
Toán tử & trả về một pointer thuộc kiểu của biến mà nó đứng trước. Trong đoạn code trên &ival trả về một pointer thuộc kiểu int, fval trả về một pointer thuộc kiểu float và &sval trả về pointer thuộc kiểu string. Những chỗ nào mà bạn có thể dùng pointer thì cũng có thể sử dụng một biến &val tương ứng.</p><ul><li>Phép gán của con trỏ chỉ thực hiện được khi kiểu dữ liệu của con trỏ phù hợp kiểu dữ liệu của biến mà nó sẽ trỏ tới.</li></ul><h2 id=gán-giá-trị-cho-con-trỏ>Gán giá trị cho con trỏ<a hidden class=anchor aria-hidden=true href=#gán-giá-trị-cho-con-trỏ>#</a></h2><p>Giá trị mà biến con trỏ lưu trữ là địa chỉ của biến khác có cùng kiểu dữ liệu với biến con trỏ.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ptr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>;
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>5</span>;

<span style=color:#a6e22e>ptr</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>value</span>;
</code></pre></div><p>Do đó, chúng ta cần sử dụng address-of operator để lấy ra địa chỉ ảo của biến rồi mới gán cho con trỏ được. Lúc này, biến ptr sẽ lưu trữ địa chỉ ảo của biến value.
<img src=https://raw.githubusercontent.com/sendo-research-team/sendo-research-team.github.io/gh-pages/static/images/5.JPG alt="Image 5">
￼</p><p>Chúng ta có thể nói rằng con trỏ ptr đang nắm giữ địa chỉ của biến value, cũng có thể nói con trỏ ptr trỏ đến biến value.
Đoạn chương trình sau sẽ in ra địa chỉ của biến value và giá trị được lưu bởi con trỏ ptr sau khi trỏ đến biến value:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>()
{
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>5</span>;
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ptr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>value</span>;
	
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>value</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ptr</span>)

}
</code></pre></div><p>Kết quả thu được trên màn hình console:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#ae81ff>0012</span><span style=color:#a6e22e>FF7C</span>
<span style=color:#ae81ff>0012</span><span style=color:#a6e22e>FF7C</span>
</code></pre></div><p>Lý do mà chúng ta gán được địa chỉ của biến value cho con trỏ kiểu int (int *) là vì address-of operator của một biến kiểu int trả về giá trị kiểu con trỏ kiểu int (int *).
Do đó, chúng ta có thể gán &value cho con trỏ kiểu int (int *).</p><p>Bên cạnh đó, khi có hai con trỏ cùng kiểu thì chúng ta có thể gán trực tiếp mà không cần sử dụng address-of operator.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
{
	<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>value</span> = <span style=color:#ae81ff>5</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ptr1</span>, <span style=color:#a6e22e>ptr2</span> <span style=color:#66d9ef>int</span>

	<span style=color:#a6e22e>ptr1</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>value</span>; <span style=color:#75715e>//ptr1 point to value
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>ptr2</span> = <span style=color:#a6e22e>ptr1</span>;   <span style=color:#75715e>//assign value of ptr1 to ptr2
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ptr1</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ptr2</span>)

}
</code></pre></div><p>Lúc này, ptr1 và ptr2 cùng giữ địa chỉ của biến value.</p><p>Truy xuất giá trị bên trong vùng nhớ mà con trỏ trỏ đến
Khi chúng ta có một con trỏ đã được trỏ đến địa chỉ nào đó trong bộ nhớ ảo, chúng ta có thể truy xuất giá trị tại địa chỉ đó bằng dereference operator. Dereference operator sẽ đánh giá nội dung địa chỉ được trỏ đến.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ptr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ptr</span> <span style=color:#75715e>//declare an int pointer
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>5</span>

<span style=color:#a6e22e>ptr</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>value</span> <span style=color:#75715e>//ptr point to value
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>value</span>) <span style=color:#75715e>//print the address of value
</span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ptr</span>)   <span style=color:#75715e>//print the address of value which is held in ptr
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>value</span>) <span style=color:#75715e>//print the content of value
</span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>*</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>value</span>)) <span style=color:#75715e>//print the content of value
</span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>ptr</span>)	<span style=color:#75715e>//print the content of value
</span></code></pre></div><p>Kết quả của đoạn chương trình trên như sau:</p><p><img src=https://raw.githubusercontent.com/sendo-research-team/sendo-research-team.github.io/gh-pages/static/images/6.JPG alt="Image 6">
￼
Toán tử trỏ đến (dereference operator) được dùng để truy cập trực tiếp vào vùng nhớ có địa chỉ cụ thể trên bộ nhớ ảo (virtual memory), vì biến con trỏ ptr đang giữ địa chỉ của biến value nên khi đặt toán tử trỏ đến (dereference operator) trước con trỏ ptr, nó sẽ truy xuất giá trị tại địa chỉ mà con trỏ ptr đang giữ.
Vì ptr có kiểu dữ liệu con trỏ int (int *), ptr chỉ có thể trỏ đến biến kiểu int. Lúc này, compiler hiểu rằng cần phân tích 4 bytes (đúng bằng kích thước kiểu int) trên bộ nhớ ảo tại địa chỉ mà ptr đang lưu trữ.
<img src=https://raw.githubusercontent.com/sendo-research-team/sendo-research-team.github.io/gh-pages/static/images/7.JPG alt="Image 7">
￼</p><p>Đây là lý do tại sao chúng ta cần khai báo kiểu dữ liệu của con trỏ. Nếu không khai báo kiểu dữ liệu cho con trỏ, toán tử trỏ đến (dereference operator) sẽ không biết phải phân tích bao nhiêu bytes tại địa chỉ con trỏ trỏ đến để tính toán được giá trị của vùng nhớ đó. Không những thế, đây còn là lý do kiểu dữ liệu của biến phải tương xứng với kiểu dữ liệu được khai báo cho con trỏ.
Vì chúng ta có thể gán lại địa chỉ mới cho một con trỏ, nên chúng ta có thể truy xuất được giá trị của nhiều vùng nhớ khác nhau chỉ với một con trỏ:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>value1</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>1</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>value2</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>2</span>

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ptr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>value1</span>
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>ptr</span>)

<span style=color:#a6e22e>ptr</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>value2</span>
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>ptr</span>)
</code></pre></div><p>Với khả năng truy cập đến vùng nhớ có địa chỉ cụ thể và thay đổi giá trị bên trong vùng nhớ của toán tử trỏ đến (dereference operator), chúng ta có thể sử dụng như sau:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>5</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ptr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>value</span>

<span style=color:#f92672>*</span><span style=color:#a6e22e>ptr</span> = <span style=color:#ae81ff>10</span>
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>ptr</span>)
</code></pre></div><p>Đoạn chương trình này sẽ in ra giá trị 10.
Có thể giải thích dòng lệnh *ptr = 10; như sau:
Biến con trỏ ptr sau khi khai báo đã được khởi tạo bằng cách gán địa chỉ của biến value. Sử dụng dereference operator cho con trỏ ptr để truy cập đến địa chỉ ảo mà ptr đang nắm giữ, gán giá trị 10 vào vùng nhớ tại vị trí đó.</p><h2 id=con-trỏ-chưa-được-gán-địa-chỉ>Con trỏ chưa được gán địa chỉ<a hidden class=anchor aria-hidden=true href=#con-trỏ-chưa-được-gán-địa-chỉ>#</a></h2><p>Con trỏ trong ngôn ngữ Golang vốn có rủi ro. Nếu sử dụng con trỏ không hợp lý có thể gây panic chương trình.
Khác với tham chiếu (reference), biến con trỏ có thể không cần khởi tạo giá trị ngay khi khai báo. Nhưng thực hiện truy xuất giá trị của con trỏ bằng dereference operator khi chưa gán địa chỉ cụ thể cho con trỏ, chương trình có thể bị đóng bởi hệ điều hành. Nguyên nhân là cố gắng đọc một con trỏ nil.
Đối với con trỏ, Nil là một giá trị đặc biệt (Zero Value), khi gán Nil cho con trỏ, điều đó có nghĩa là con trỏ đó chưa trỏ đến địa chỉ nào cả. Con trỏ đang giữ giá trị Nil được gọi là con trỏ Nil (Nil pointer).</p><h2 id=tổng-kết>Tổng kết<a hidden class=anchor aria-hidden=true href=#tổng-kết>#</a></h2><p>Trong bài học này, các bạn đã được tìm hiểu khái niệm con trỏ và một số khái niệm có liên quan. Việc sử dụng con trỏ thường có một số hoạt động chủ yếu:</p><ul><li>khai báo một con trỏ.</li><li>gán địa chỉ cho con trỏ.</li><li>truy cập đến địa chỉ mà con trỏ đang nắm giữ bằng dereference operator.</li></ul><p>Thử liên hệ một chút với cuộc sống thực tế, tưởng tượng rằng con đường nhà bạn (street) là bộ nhớ ảo, trên con đường đó có rất nhiều ngôi nhà (house), mỗi ngôi nhà đều được đánh số thứ tự gọi là địa chỉ nhà (house&rsquo;s address). Chúng ta tạm hình dung số người ở trong mỗi ngôi nhà (content) tương đương với nội dung của mỗi ô trên bộ nhớ ảo.</p><p>Như vậy, address-of operator (&house) sẽ trả về địa chỉ của ngôi nhà, dereference operator (*&house) sẽ lấy ra số lượng người bên trong ngôi nhà có địa chỉ được xác định. Để sử dụng con trỏ trỏ đến mỗi ngôi nhà, chúng ta phải sử dụng một con trỏ kiểu House (giống với kiểu của từng ngôi nhà), giả sử con trỏ kiểu House được khai báo là House *h_ptr; thì con trỏ h_ptr có thể trỏ đến bất kì ngôi nhà nào trên con đường, và nó còn có thể thay đổi nội dung bên trong từng ngôi nhà mà nó trỏ đến.</p><p>Con trỏ (Pointer) là một công cụ mạnh mẽ đặc trưng của ngôn ngữ Golang. Con trỏ cho phép chúng ta chia sẻ data của chương trình trên bộ nhớ ảo.</p><p><em>- Pham Minh Toan -</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sdt-research-team.github.io/tags/go/>go</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Pointer Definition on twitter" href="https://twitter.com/intent/tweet/?text=Pointer%20Definition&url=https%3a%2f%2fsdt-research-team.github.io%2fposts%2fpointer-definition%2f&hashtags=go"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Pointer Definition on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fsdt-research-team.github.io%2fposts%2fpointer-definition%2f&title=Pointer%20Definition&summary=Pointer%20Definition&source=https%3a%2f%2fsdt-research-team.github.io%2fposts%2fpointer-definition%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Pointer Definition on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsdt-research-team.github.io%2fposts%2fpointer-definition%2f&title=Pointer%20Definition"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Pointer Definition on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsdt-research-team.github.io%2fposts%2fpointer-definition%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Pointer Definition on whatsapp" href="https://api.whatsapp.com/send?text=Pointer%20Definition%20-%20https%3a%2f%2fsdt-research-team.github.io%2fposts%2fpointer-definition%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Pointer Definition on telegram" href="https://telegram.me/share/url?text=Pointer%20Definition&url=https%3a%2f%2fsdt-research-team.github.io%2fposts%2fpointer-definition%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2020 <a href=https://sdt-research-team.github.io>Research Team</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><button class=top-link id=top-link type=button aria-label="go to top" title="Go to Top (Alt + G)" accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button>
<script defer src=https://sdt-research-team.github.io/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};mybutton.onclick=function(){document.body.scrollTop=0;document.documentElement.scrollTop=0;window.location.hash=''}
function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>